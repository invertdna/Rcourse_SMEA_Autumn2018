knitr::opts_chunk$set(echo = TRUE, eval=T)
x <- 1972
y <- "1972"
x
y
x + 10
#which is the same as
1972+10
x
x <- x + 10
x
num.vec <- c(1,2,3,4,5,6)
char.vec <- c("a", "b", "c", "d")
mixed.vec <- c(1, "a", 2, 7, TRUE)
num.vec + 5  #add 5 to each element of numeric vector
toupper(char.vec)  #use function "toupper" to change the case of character vector from lower to upper
paste(mixed.vec, collapse="_") #use function "paste" to collapse the elements of the mixed vector into a single character string, separated by underscores
?pirates
#load the data into memory, using function read.csv to read in the table
pirates <- yarrr::pirates #read.csv("../Data/pirates.csv")
# Look at the first few rows of the data
head(pirates)
# What are the names of the columns?
names(pirates)
# What is the mean age?
mean(pirates$age)
# What was the tallest pirate?
max(pirates$height)
# How many pirates are there, by age?
table(pirates$age)
# Calculate the mean age, separately for each sex
aggregate(formula = age ~ sex,
data = pirates,
FUN = mean)
# Create scatterplot
plot(x = pirates$height,        # X coordinates
y = pirates$weight)        # y-coordinates
# Create scatterplot
plot(x = pirates$height,        # X coordinates
y = pirates$weight,        # y-coordinates
main = 'My first scatterplot of pirate data!',
xlab = 'Height (in cm)',   # x-axis label
ylab = 'Weight (in kg)',   # y-axis label
pch = 16,                  # Filled circles
col = gray(.0, .1))        # Transparent gray
# Create scatterplot
plot(x = pirates$height,        # X coordinates
y = pirates$weight,        # y-coordinates
main = 'My first scatterplot of pirate data!',
xlab = 'Height (in cm)',   # x-axis label
ylab = 'Weight (in kg)',   # y-axis label
pch = 16,                  # Filled circles
col = gray(.0, .1))        # Transparent gray
grid()        # Add gridlines
# Create a linear regression model
model <- lm(formula = weight ~ height,
data = pirates)
abline(model, col = 'blue')      # Add regression to plot
yarrr::pirateplot(formula = age ~ sword.type,
data = pirates,
main = "Pirateplot of ages by favorite sword")
hist(pirates$age)
print("hello")
#
print("hello")
#
print("hello")
a.1 <- "hello"
"bye" -> a.2
print(a.1)
c(a.1, a.2)
num.vec <- c(1,2,3,4,5,6)
num.vec
class(num.vec)
num.vec+5
char.vec <- c("a", "b", "c", "d")
char.vec+5
toupper(char.vec)
mixed.vec <- c(1, "a", 2, 7, TRUE)
mixed.vec
paste(mixed.vec, sep="_")
paste(mixed.vec, sep="_", collapse = T)
paste(mixed.vec, collapse = "_")
paste(mixed.vec[1:2], collapse = "_")
install.packages("yarrr")
install.packages("yarrr")
?yarrr
library(yarrr)
?yarrr
?yarrr.guide
?c
??paste
pirates
head(pirates)
summary(pirates)
pirates$age
mean(pirates$age)
pirates[pirates$age == 11,]
pirates[pirates$height > 180,]
hist(pirates$age)
hist(pirates$age,col = "blue")
table(pirates$college, pirates$sex)
table(pirates$college, pirates$sex, pirates$age)
table(pirates$college, pirates$age, pirates$sex)
table(pirates$college, pirates$sex)
boxplot(pirates$age~pirates$sex)
boxplot(pirates$age~pirates$sex)
boxplot(pirates$age~pirates$sex)
boxplot(pirates$age~pirates$sex, col = "navy")
boxplot(pirates$age~pirates$sex, col = "navy")
pdf("test.pdf")
boxplot(pirates$age~pirates$sex, col = "navy")
dev.off()
boxplot(pirates$age~pirates$sex, col = "navy")
boxplot(pirates$age~pirates$sex, col = "gold")
library(ggplot2)
library(yarrr)
diamonds <- yarrr::diamonds  #to prevent conflict among packages; ggplot2 also has a dataframe called "diamonds"
set.seed(49)  #for repeatability
x <- rnorm(25, mean = 10, sd = 2)  #draw 25 random numbers from a normal distribution with mean 10 and standard deviation 2
mean(x)
y <- rnorm(25, mean = 11, sd = 2)  #draw 25 random numbers from a normal distribution with mean 11 and standard deviation 2
mean(y)
#visualize these distributions in a histogram
par(mfrow=c(2,1))
hist(x, breaks = 10, ylim = c(0,10), xlim = c(5,17))
abline(v=mean(x), col="red")
hist(y, col="lightgrey", breaks = 10, ylim = c(0,10), xlim = c(5,17))
abline(v=mean(y), col="blue")
t.test(x, y)  #t-test is trivially easy to run in R; it's built-in.
#note there are options for one-sample t-tests, one-tailed paired t-tests, etc.  see ?t.test
t.test.results <- t.test(x,y)
wilcox.test(x,y)  #super useful; doesn't assume normal distributions
ks.test(x, y)  #Kolmogorov-Smirnov test; similar.
#you get the point.
plot (value~weight, data=diamonds)
cor.test(diamonds$weight, diamonds$value) #Pearson, by default, but Kendall and Spearman are also available. The give similar results.
#note: if you just want the correlation coefficient, and not to do the test, you can just use
cor(diamonds$weight, diamonds$value, method = "pearson")
lm.result <- lm(value~weight, data=diamonds)  #yvariable~xvariable is the formula
summary(lm.result) #a useful way to look at the results
#predict the value of diamonds of weights 190, 200, and 201 grams
predict(lm.result, newdata = data.frame(weight =c(190, 200 ,210)))
plot (value~weight, data=diamonds,
pch = 19, xlab = "Weight of Diamonds (grams)", ylab = "Value (Doubloons") #here, let's use filled-in dots and label the axes appropriately
#now we add the best-fit line from the linear model we saved above
abline(lm.result,
col = "purple", #we'll color it purple
lwd = 2, #and make it thick (lwd, for "line width")
lty = 2)   #dashed (lty = 2, for "line type")
#confidence intervals would be nice to add, which is easy in ggplot, but hard in base R.  See this, if you're interested: https://stackoverflow.com/questions/43692394/shading-confidence-intervals-in-r-base-r-if-possible
mult.lm.result <- lm(value ~ weight + clarity, data = diamonds)
summary(mult.lm.result)  #here's the same output, but with another term... the estimate for clarity as well as weight and the intercept.
#make an ANOVA object
anova.result <- aov(value ~ weight + clarity, data = diamonds)
summary(anova.result)
coefficients(anova.result)  #note this is the same as
coefficients(mult.lm.result)  #!
total.variance <- sum(as.data.frame(summary(anova.result)[[1]])[,2]) #sum up the sums of squares
#fraction of variance explained by each of the factors (akin to the Rsquared value of the lm):
SumSquares <- data.frame(
factors = row.names(as.data.frame(summary(anova.result)[[1]])),
Rsquared =as.data.frame(summary(anova.result)[[1]])[,2] / total.variance
)
sum(SumSquares[1:2, 2])  #the same Rsquared value we get from the multiple linear model
diamonds$ClaritySet <- ifelse(diamonds$clarity <= mean(diamonds$clarity), "lower", "higher")  #create bins of clarity above and below mean clarity
ggplot(diamonds, aes(y = value, x = weight, color = ClaritySet))+
geom_point()+
geom_smooth(method = "lm")
#install.packages("broom") - do this the first time
library(broom)
tidy(anova.result)
anova.full <- augment(anova.result)
anova.full
ggplot(anova.full, aes(y = .resid, x = weight, color = diamonds$ClaritySet))+
geom_point()
ggplot(anova.full, aes(y = .resid, x = clarity, color = weight))+
geom_point()
glance(anova.result)
nrow(diamonds) #150
set.seed(2) # so we all get the same results
dvide <- sample (x = nrow(diamonds), # Create the vector of which samples go
size = 105,         # for training
replace = FALSE)    # without replacing them
diamonds[dvide,] -> training.dataset # 105 observations into training
diamonds[-dvide,] -> test.dataset    # 45 observations into test
anova.tr <- aov(value ~ weight + clarity, data =training.dataset )
tidy (anova.tr)
anova.training.points <- augment(anova.tr)
anova.test <- augment (anova.tr, newdata = test.dataset)
anova.test
bind_rows(anova.training.points,anova.test)
??bind_rows
library(dplyr)
library(ggplot2)
library(yarrr)
library(dplyr)
diamonds <- yarrr::diamonds  #to prevent conflict among packages; ggplot2 also has a dataframe called "diamonds"
set.seed(49)  #for repeatability
x <- rnorm(25, mean = 10, sd = 2)  #draw 25 random numbers from a normal distribution with mean 10 and standard deviation 2
mean(x)
y <- rnorm(25, mean = 11, sd = 2)  #draw 25 random numbers from a normal distribution with mean 11 and standard deviation 2
mean(y)
#visualize these distributions in a histogram
par(mfrow=c(2,1))
hist(x, breaks = 10, ylim = c(0,10), xlim = c(5,17))
abline(v=mean(x), col="red")
hist(y, col="lightgrey", breaks = 10, ylim = c(0,10), xlim = c(5,17))
abline(v=mean(y), col="blue")
t.test(x, y)  #t-test is trivially easy to run in R; it's built-in.
#note there are options for one-sample t-tests, one-tailed paired t-tests, etc.  see ?t.test
t.test.results <- t.test(x,y)
wilcox.test(x,y)  #super useful; doesn't assume normal distributions
ks.test(x, y)  #Kolmogorov-Smirnov test; similar.
#you get the point.
plot (value~weight, data=diamonds)
cor.test(diamonds$weight, diamonds$value) #Pearson, by default, but Kendall and Spearman are also available. The give similar results.
#note: if you just want the correlation coefficient, and not to do the test, you can just use
cor(diamonds$weight, diamonds$value, method = "pearson")
lm.result <- lm(value~weight, data=diamonds)  #yvariable~xvariable is the formula
summary(lm.result) #a useful way to look at the results
#predict the value of diamonds of weights 190, 200, and 201 grams
predict(lm.result, newdata = data.frame(weight =c(190, 200 ,210)))
plot (value~weight, data=diamonds,
pch = 19, xlab = "Weight of Diamonds (grams)", ylab = "Value (Doubloons") #here, let's use filled-in dots and label the axes appropriately
#now we add the best-fit line from the linear model we saved above
abline(lm.result,
col = "purple", #we'll color it purple
lwd = 2, #and make it thick (lwd, for "line width")
lty = 2)   #dashed (lty = 2, for "line type")
#confidence intervals would be nice to add, which is easy in ggplot, but hard in base R.  See this, if you're interested: https://stackoverflow.com/questions/43692394/shading-confidence-intervals-in-r-base-r-if-possible
mult.lm.result <- lm(value ~ weight + clarity, data = diamonds)
summary(mult.lm.result)  #here's the same output, but with another term... the estimate for clarity as well as weight and the intercept.
#make an ANOVA object
anova.result <- aov(value ~ weight + clarity, data = diamonds)
summary(anova.result)
coefficients(anova.result)  #note this is the same as
coefficients(mult.lm.result)  #!
total.variance <- sum(as.data.frame(summary(anova.result)[[1]])[,2]) #sum up the sums of squares
#fraction of variance explained by each of the factors (akin to the Rsquared value of the lm):
SumSquares <- data.frame(
factors = row.names(as.data.frame(summary(anova.result)[[1]])),
Rsquared =as.data.frame(summary(anova.result)[[1]])[,2] / total.variance
)
sum(SumSquares[1:2, 2])  #the same Rsquared value we get from the multiple linear model
diamonds$ClaritySet <- ifelse(diamonds$clarity <= mean(diamonds$clarity), "lower", "higher")  #create bins of clarity above and below mean clarity
ggplot(diamonds, aes(y = value, x = weight, color = ClaritySet))+
geom_point()+
geom_smooth(method = "lm")
#install.packages("broom") - do this the first time
library(broom)
tidy(anova.result)
anova.full <- augment(anova.result)
anova.full
ggplot(anova.full, aes(y = .resid, x = weight, color = diamonds$ClaritySet))+
geom_point()
ggplot(anova.full, aes(y = .resid, x = clarity, color = weight))+
geom_point()
glance(anova.result)
nrow(diamonds) #150
set.seed(2) # so we all get the same results
dvide <- sample (x = nrow(diamonds), # Create the vector of which samples go
size = 105,         # for training
replace = FALSE)    # without replacing them
diamonds[dvide,] -> training.dataset # 105 observations into training
diamonds[-dvide,] -> test.dataset    # 45 observations into test
anova.tr <- aov(value ~ weight + clarity, data =training.dataset )
tidy (anova.tr)
anova.training.points <- augment(anova.tr)
anova.test <- augment (anova.tr, newdata = test.dataset)
anova.test
bind_rows(anova.training.points,anova.test)
ggplot( data = anova.training.points,
aes(x = value,
y = .fitted)) +
geom_point(color = "blue") +
geom_point (data = anova.test,
aes(x= value,
y= .fitted),
color = "red")
knitr::opts_chunk$set(echo = TRUE, eval=T)
library(yarrr)
dim(pirates)
names(pirates)
pirates$tchests
#we could then summarize this or plot it, or whatever...
summary(pirates$tchests)
sum(c(1,4,6,8))
3+2
sum(3,1)
sum(3,2)
sum(c(1,2,4,5),2)
?sum
#*2
3*2
10e-3
summary(AirPassengers)
summary(pirates)
dim(pirates)
dim(pirates)[1]
nrow(pirates)
dim(pirates)
x<-1:100
dim(x)
length(x)
x <- c(1,5,7,2,8,10,3,8,5,4)
x
x[4]
names(x)
pirates[2,3]
pirates[2,]
pirates[2]
pirates[,2]
pirates[,]
pirates[,2]
paste(pirates[,2], "red")
table(pirates[,2])
colnames(pirates)
paste(pirates[,7],pirates[,12])
names(table(pirates[,2]))
sort(names(table(pirates[,2])))
x
x[3:10]
x[10:3]
x[c(4,7,9)]
1:10
seq(1,10,1)
names(pirates)
pirates[,9]
pirates[,"tchests"]
pirates$tchests
table(pirates$tchests)
hist(pirates$tchests)
WorldPhones
dim(WorldPhones)
?data
data()
(Amers <- WorldPhones[,c("N.Amer", "S.Amer", "Mid.Amer")])
A1 <- WorldPhones[,c(1,4,7)]
A1 == Amers
totals<-rowSums(Amers)
totals
Amers
rowSums(Amers)
is.numeric(row.names(Amers))
plot(totals~row.names(Amers))
years <- as.numeric(row.names(Amers))
years
is.numeric(years)
plot(totals~years)
plot(totals~years)
abline(lm(totals~years), col="red")
grep(pattern = "Ame", colnames(WorldPhones))
WorldPhones[,grep(pattern = "Ame", colnames(WorldPhones))]
read.table("",header = TRUE, sep = "")
fromweb <- read.table(file = 'http://goo.gl/jTNf6P',
sep = '\t',
header = TRUE)
View(fromweb)
summary(pirates)
pirates$sword.factor <- as.factor(pirates$sword.type)
summary (pirates)
knitr::opts_chunk$set(echo = TRUE, eval=T)
library(yarrr)
library(dplyr)
library(wesanderson)
# A basic scatterplot
plot(x = 1:10,  #this creates a vector from one to 10
y = 1:10,  #this does the same
xlab = "X Axis label",
ylab = "Y Axis label",
main = "Main Title")
plot(y=1:10, x=1:11)
names(pirates)
plot(height~weight, data=pirates)
plot(pirates$height~pirates$weight)
plot(height~weight,
data=pirates,
ylim=c(0,0.5),
xlim=c(0,3)
)
plot(height~weight,
data=pirates,
ylim=c(150,160),
xlim=c(60,80)
)
plot(height~weight,
data=pirates,
ylim=c(140,160),
xlim=c(60,80)
)
plot(height~weight,
data=pirates,
ylim=c(150,160),
xlim=c(50,80)
)
par(mar  = c(1, 1, 3, 1))  #here, we are changing the margins, which you don't need to worry about yet
plot(x = rep(1:5 + .1, each = 5),  #create an x vector by repeating some numbers 5 times each
y = rep(5:1, times = 5),      #same for y
pch = 1:25,      #plot characters 1 through 25 (this is to show you the different plot characters)
xlab = "", ylab = "", xaxt = "n", yaxt = "n",  #remove x and y axes and labels
xlim = c(.5, 5.5),  #set the min/max x-axis limits
ylim = c(0, 6),    #set the min/max y-axis limits
bty = "n", bg = "gray", cex = 1.4,   #don't make a box around the figure, make the background gray, and make the plot characters 1.4 times their normal sizes
main = "pch = _"   #create a title
)
text(x = rep(1:5, each = 5) - .35,
y = rep(5:1, times = 5),
labels = 1:25, cex = 1.2
)
par(mar  = c(1, 1, 3, 1))  #here, we are changing the margins, which you don't need to worry about yet
plot(x = rep(1:5 + .1, each = 5),  #create an x vector by repeating some numbers 5 times each
y = rep(5:1, times = 5),      #same for y
pch = 1:25,      #plot characters 1 through 25 (this is to show you the different plot characters)
xlab = "", ylab = "", xaxt = "n", yaxt = "n",  #remove x and y axes and labels
xlim = c(.5, 5.5),  #set the min/max x-axis limits
ylim = c(0, 6),    #set the min/max y-axis limits
bty = "n", bg = "gray", cex = 1.4,   #don't make a box around the figure, make the background gray, and make the plot characters 1.4 times their normal sizes
main = "pch = _"   #create a title
)
text(x = rep(1:5, each = 5) - .35,   #now add text to that same plot to label each plotting character
y = rep(5:1, times = 5),
labels = 1:25, cex = 1.2
)
plot(y~x,
pch="W"
)
plot(y = 1:10,
x = sample(1:10, 10),
pch="W"
)
set.seed(100)
par(mar = c(0, 0, 0, 0))
plot(1, xlim = c(0, 11), ylim = c(0, 11),
type = "n", bty = "n", xaxt = "n", yaxt = "n",
xlab = "", ylab = "")
loc <- expand.grid(x = 1:10, y = 1:10)
col.vec <- colors()[sample(1:length(colors()), size = 100)]
for(i in 1:nrow(loc)) {
x.i <- loc$x[i]
y.i <- loc$y[i]
rect(x.i - .5, y.i - .5,
x.i + .5, y.i + .5,
col = col.vec[i], border = "white")
text(x.i, y.i, labels = col.vec[i], cex = .6)
}
library(wesanderson)
wes_palette("Zissou1")  #show the colors in the wesanderson palette "Zissou1"
plot(y~x,
col=wes_palette("Zissou1")[1],
pch=19) #make the sine plot, but using the first Zissou1 color and use solid circles as the plot character
knitr::opts_chunk$set(echo = TRUE, eval=T)
library(yarrr)
library(dplyr)
library(wesanderson)
wes_palette("Zissou1")  #show the colors in the wesanderson palette "Zissou1"
x <- seq(0, 7, 0.01)
y <- sin(x)
plot(y~x,
col=wes_palette("Zissou1")[1],
pch=19) #make the sine plot, but using the first Zissou1 color and use solid circles as the plot character
plot(y~x,
col=wes_palette("Zissou1")[1],
pch=19) #make the sine plot, but using the first Zissou1 color and use solid circles as the plot character
abline(h=0,
col=wes_palette("Zissou1")[5],
lwd = 2) #draw a horizontal line at y = 0, using a Zissou1 color
plot(y~x,
col=wes_palette("Zissou1")[1],
pch=19) #make the sine plot, but using the first Zissou1 color and use solid circles as the plot character
abline(h=0,
col=wes_palette("Zissou1")[5],
lwd = 2) #draw a horizontal line at y = 0, using a Zissou1 color
abline(h=0.5,
col=wes_palette("Zissou1")[3],
lwd = 2,
lty = 4) #draw a horizontal line at y = 0.5, using a Zissou1 color, and make it a dashed line (lty ... "for line type")
abline(h=-0.5,
col=wes_palette("Zissou1")[4],
lwd = 2,
lty = 4) #draw a horizontal line at y = -0.5, using a Zissou1 color, and make it a dashed line (lty ... "for line type")
hist(x = ChickWeight$weight,
main = "Chicken Weights",
xlab = "Weight",
xlim = c(0, 500))
hist(x = ChickWeight$weight,
main = "Fancy Chicken Weight Histogram",
xlab = "Weight",
ylab = "Frequency",
breaks = 20, # 20 Bins
xlim = c(0, 500),
col = "papayawhip", # Filling Color
border = "hotpink") # Border Color
hist(x = ChickWeight$weight[ChickWeight$Diet == 1],
main = "Two Histograms in one",
xlab = "Weight",
ylab = "Frequency",
breaks = 20,
xlim = c(0, 500),
col = gray(0, .5))
hist(x = ChickWeight$weight[ChickWeight$Diet == 2],
breaks = 30,
add = TRUE, # Add plot to previous one!
col = gray(1, .8))
library(ggplot2)
levels(ChickWeight$Diet)<-c("Diet 1", "Diet 2", "Diet 3", "Diet 4")  #relabel Diet categories for clarity in graphing
ggplot(data = ChickWeight, aes(x=Time, y=weight, color=Chick))+
geom_line()+
facet_grid(~Diet)+
guides(color=guide_legend(ncol=4))+
labs(color="Chick")+
ggtitle("Chick Weight by Time and Diet")
